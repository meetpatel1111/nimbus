name: Nimbus - Complete Deployment Pipeline

on:
  # push:
  #   branches: [ main ]
  workflow_dispatch:
    inputs:
      cloud_provider:
        description: 'Cloud Provider'
        required: true
        type: choice
        options:
          - none
          - aws
          - azure
        default: aws
      instance_name:
        description: 'Instance/VM Name'
        required: false
        default: 'nimbus-cloud'
      region:
        description: 'Cloud Region'
        required: false
        default: 'us-east-1'
      run_bootstrap:
        description: 'Run bootstrap script after deployment'
        required: false
        type: boolean
        default: false
      deploy_app:
        description: 'Deploy Nimbus Cloud application to cluster'
        required: false
        type: boolean
        default: true

env:
  IMAGE_NAME: nimbus-platform
  REGISTRY: ${{ secrets.REGISTRY || 'docker.io' }}
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  KUBE_NAMESPACE: nimbus

jobs:
  # Job 1: Build and Test
  build-and-test:
    name: Build & Test Application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install backend dependencies
        run: |
          cd backend
          npm install

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Upload frontend build
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

  # Job 2: Build and Push Docker Images
  build-docker-images:
    name: Build & Push Docker Images
    needs: build-and-test
    runs-on: ubuntu-latest
    outputs:
      frontend_image: ${{ steps.meta-frontend.outputs.tags }}
      backend_image: ${{ steps.meta-backend.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: ${{ env.DOCKER_USERNAME != '' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Docker meta - Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=frontend-
            type=raw,value=frontend-latest

      - name: Build & push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: ${{ env.DOCKER_USERNAME != '' }}
          tags: ${{ steps.meta-frontend.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Docker meta - Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=backend-
            type=raw,value=backend-latest

      - name: Build & push backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: ${{ env.DOCKER_USERNAME != '' }}
          tags: ${{ steps.meta-backend.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 3: Deploy Infrastructure (AWS)
  deploy-aws-infrastructure:
    name: Deploy AWS Infrastructure
    needs: build-and-test
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.cloud_provider == 'aws' }}
    outputs:
      instance_ip: ${{ steps.terraform-output.outputs.public_ip }}
      instance_id: ${{ steps.terraform-output.outputs.instance_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.region || 'us-east-1' }}

      - name: Setup SSH key from secret
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Create S3 backend if not exists
        continue-on-error: true
        run: |
          BUCKET_NAME="nimbus-tfstate-meetpatel1111"
          
          # Create S3 bucket for state in us-east-1
          aws s3api create-bucket \
            --bucket $BUCKET_NAME \
            --region us-east-1 2>&1 | grep -v "BucketAlreadyOwnedByYou" || true
          
          # Enable versioning
          aws s3api put-bucket-versioning \
            --bucket $BUCKET_NAME \
            --versioning-configuration Status=Enabled 2>/dev/null || true
          
          # Enable encryption
          aws s3api put-bucket-encryption \
            --bucket $BUCKET_NAME \
            --server-side-encryption-configuration '{
              "Rules": [{
                "ApplyServerSideEncryptionByDefault": {
                  "SSEAlgorithm": "AES256"
                }
              }]
            }' 2>/dev/null || true
          
          # Block public access
          aws s3api put-public-access-block \
            --bucket $BUCKET_NAME \
            --public-access-block-configuration \
              BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true \
            2>/dev/null || true
          
          # Create DynamoDB table for locking
          aws dynamodb create-table \
            --table-name nimbus-terraform-locks \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region us-east-1 2>&1 | grep -v "ResourceInUseException" || true

      - name: Terraform Init
        run: |
          cd infra/terraform/aws
          terraform init

      - name: Terraform Plan
        run: |
          cd infra/terraform/aws
          terraform plan \
            -var="instance_name=${{ github.event.inputs.instance_name || 'nimbus-cloud' }}" \
            -var="aws_region=${{ github.event.inputs.region || 'us-east-1' }}" \
            -var="key_pair_name=nimbus" \
            -out=tfplan

      - name: Terraform Apply
        run: |
          cd infra/terraform/aws
          terraform apply -auto-approve tfplan
      
      - name: Install K3s and Helm (minimal setup for Nimbus Cloud)
        if: github.event.inputs.run_bootstrap == 'false'
        run: |
          INSTANCE_IP=$(cd infra/terraform/aws && terraform output -raw public_ip)
          
          echo "Installing K3s and Helm on $INSTANCE_IP..."
          ssh -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP << 'EOF'
            # Wait for cloud-init to finish
            while [ ! -f /var/lib/cloud/instance/boot-finished ]; do
              echo "Waiting for cloud-init..."
              sleep 2
            done
            
            # Install K3s
            curl -sfL https://get.k3s.io | sh -
            
            # Wait for K3s to be ready
            sudo kubectl wait --for=condition=Ready nodes --all --timeout=300s
            
            # Install Helm
            curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
            
            # Add essential Helm repos for service deployment
            helm repo add bitnami https://charts.bitnami.com/bitnami
            helm repo add grafana https://grafana.github.io/helm-charts
            helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
            helm repo add harbor https://helm.goharbor.io
            helm repo add hashicorp https://helm.releases.hashicorp.com
            helm repo add gitea-charts https://dl.gitea.io/charts/
            helm repo add minio https://charts.min.io/
            helm repo add traefik https://helm.traefik.io/traefik
            helm repo add longhorn https://charts.longhorn.io
            helm repo add nats https://nats-io.github.io/k8s/helm/charts/
            helm repo add openfaas https://openfaas.github.io/faas-netes/
            helm repo add jetstack https://charts.jetstack.io
            helm repo add kyverno https://kyverno.github.io/kyverno/
            helm repo add jaegertracing https://jaegertracing.github.io/helm-charts
            helm repo add vmware-tanzu https://vmware-tanzu.github.io/helm-charts
            helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
            helm repo add istio https://istio-release.storage.googleapis.com/charts
            helm repo add argo https://argoproj.github.io/argo-helm
            helm repo add drone https://charts.drone.io
            helm repo update
            
            # Create namespaces for Nimbus Cloud
            sudo kubectl create namespace nimbus --dry-run=client -o yaml | sudo kubectl apply -f -
            sudo kubectl create namespace apps --dry-run=client -o yaml | sudo kubectl apply -f -
            sudo kubectl create namespace monitoring --dry-run=client -o yaml | sudo kubectl apply -f -
            sudo kubectl create namespace ci --dry-run=client -o yaml | sudo kubectl apply -f -
            sudo kubectl create namespace storage --dry-run=client -o yaml | sudo kubectl apply -f -
            
            echo "âœ… K3s and Helm ready for Nimbus Cloud!"
          EOF

      - name: Get Terraform Outputs
        id: terraform-output
        run: |
          cd infra/terraform/aws
          echo "public_ip=$(terraform output -raw public_ip)" >> $GITHUB_OUTPUT
          echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT

      - name: Save Terraform State
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state-aws
          path: infra/terraform/aws/terraform.tfstate

  # Job 4: Deploy Infrastructure (Azure)
  deploy-azure-infrastructure:
    name: Deploy Azure Infrastructure
    needs: build-and-test
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.cloud_provider == 'azure' }}
    outputs:
      instance_ip: ${{ steps.terraform-output.outputs.public_ip }}
      vm_id: ${{ steps.terraform-output.outputs.vm_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Setup SSH key from secret
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Extract public key from private key
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub

      - name: Terraform Init
        run: |
          cd infra/terraform/azure
          terraform init

      - name: Terraform Plan
        env:
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          cd infra/terraform/azure
          terraform plan \
            -var="vm_name=${{ github.event.inputs.instance_name || 'nimbus-cloud' }}" \
            -var="location=${{ github.event.inputs.region || 'eastus' }}" \
            -var="ssh_public_key=$(cat ~/.ssh/id_rsa.pub)" \
            -out=tfplan

      - name: Terraform Apply
        env:
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          cd infra/terraform/azure
          terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: terraform-output
        run: |
          cd infra/terraform/azure
          echo "public_ip=$(terraform output -raw public_ip)" >> $GITHUB_OUTPUT
          echo "vm_id=$(terraform output -raw vm_id)" >> $GITHUB_OUTPUT

      - name: Save Terraform State
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state-azure
          path: infra/terraform/azure/terraform.tfstate

  # Job 5: Run Bootstrap Script
  run-bootstrap:
    name: Bootstrap Mini-Cloud Services
    needs: [deploy-aws-infrastructure, deploy-azure-infrastructure]
    runs-on: ubuntu-latest
    if: |
      always() && 
      (needs.deploy-aws-infrastructure.result == 'success' || needs.deploy-azure-infrastructure.result == 'success') &&
      github.event.inputs.run_bootstrap == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get instance IP
        id: get-ip
        run: |
          if [ "${{ needs.deploy-aws-infrastructure.result }}" == "success" ]; then
            echo "ip=${{ needs.deploy-aws-infrastructure.outputs.instance_ip }}" >> $GITHUB_OUTPUT
            echo "user=ubuntu" >> $GITHUB_OUTPUT
          else
            echo "ip=${{ needs.deploy-azure-infrastructure.outputs.instance_ip }}" >> $GITHUB_OUTPUT
            echo "user=azureuser" >> $GITHUB_OUTPUT
          fi

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
      - name: Add host to known_hosts
        run: |
          ssh-keyscan -H ${{ steps.get-ip.outputs.ip }} >> ~/.ssh/known_hosts || echo "Failed to add host to known_hosts, will try with StrictHostKeyChecking=no"

      - name: Wait for instance to be ready
        run: |
          echo "Waiting for instance to be ready..."
          for i in {1..30}; do
            if ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no ${{ steps.get-ip.outputs.user }}@${{ steps.get-ip.outputs.ip }} "echo 'Instance ready'"; then
              echo "Instance is ready!"
              break
            fi
            echo "Attempt $i: Instance not ready yet, waiting..."
            sleep 10
          done

      - name: Copy bootstrap script
        run: |
          scp -o StrictHostKeyChecking=no bootstrap/full-mini-cloud-bootstrap-fixed.sh \
            ${{ steps.get-ip.outputs.user }}@${{ steps.get-ip.outputs.ip }}:~/

      - name: Run bootstrap script
        continue-on-error: true
        run: |
          ssh -o StrictHostKeyChecking=no ${{ steps.get-ip.outputs.user }}@${{ steps.get-ip.outputs.ip }} \
            "sudo bash ~/full-mini-cloud-bootstrap-fixed.sh" | tee bootstrap.log

      - name: Upload bootstrap log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bootstrap-log
          path: bootstrap.log

      - name: Retrieve secrets
        continue-on-error: true
        run: |
          ssh -o StrictHostKeyChecking=no ${{ steps.get-ip.outputs.user }}@${{ steps.get-ip.outputs.ip }} \
            "sudo cat /root/.mini-cloud-secrets" > mini-cloud-secrets.txt 2>/dev/null || \
            echo "Secrets file not found - bootstrap may still be running" > mini-cloud-secrets.txt

      - name: Upload secrets
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mini-cloud-secrets
          path: mini-cloud-secrets.txt

  # Job 6: Deploy Application to Kubernetes
  deploy-to-kubernetes:
    name: Deploy Application to K8s
    needs: [deploy-aws-infrastructure, deploy-azure-infrastructure, build-docker-images]
    runs-on: ubuntu-latest
    if: |
      always() && 
      (needs.deploy-aws-infrastructure.result == 'success' || needs.deploy-azure-infrastructure.result == 'success') &&
      needs.build-docker-images.result == 'success' &&
      github.event.inputs.deploy_app == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.3'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'

      - name: Get instance IP
        id: get-ip
        run: |
          if [ "${{ needs.deploy-aws-infrastructure.result }}" == "success" ]; then
            echo "ip=${{ needs.deploy-aws-infrastructure.outputs.instance_ip }}" >> $GITHUB_OUTPUT
            echo "user=ubuntu" >> $GITHUB_OUTPUT
          else
            echo "ip=${{ needs.deploy-azure-infrastructure.outputs.instance_ip }}" >> $GITHUB_OUTPUT
            echo "user=azureuser" >> $GITHUB_OUTPUT
          fi

      - name: Setup SSH and get kubeconfig
        run: |
          mkdir -p ~/.ssh ~/.kube
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-ip.outputs.ip }} >> ~/.ssh/known_hosts
          
          # Copy kubeconfig from remote server (requires sudo)
          ssh -o StrictHostKeyChecking=no ${{ steps.get-ip.outputs.user }}@${{ steps.get-ip.outputs.ip }} \
            "sudo cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config
          
          # Replace localhost with actual IP
          sed -i "s/127.0.0.1/${{ steps.get-ip.outputs.ip }}/g" ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Deploy Nimbus to Kubernetes (via SSH)
        run: |
          # Copy Helm chart to remote server
          scp -o StrictHostKeyChecking=no -r ./helm/nimbus ${{ steps.get-ip.outputs.user }}@${{ steps.get-ip.outputs.ip }}:~/
          
          # Deploy via SSH on the remote server
          ssh -o StrictHostKeyChecking=no ${{ steps.get-ip.outputs.user }}@${{ steps.get-ip.outputs.ip }} << 'EOF'
            # Wait for K3s to be fully ready
            sudo kubectl wait --for=condition=Ready nodes --all --timeout=300s
            
            # Create namespace
            sudo kubectl create namespace nimbus --dry-run=client -o yaml | sudo kubectl apply -f -
            
            # Deploy with Helm
            sudo helm upgrade --install nimbus ~/nimbus \
              -n nimbus \
              --set backend.image=${{ needs.build-docker-images.outputs.backend_image }} \
              --set frontend.image=${{ needs.build-docker-images.outputs.frontend_image }} \
              --wait \
              --timeout 10m
            
            # Verify deployment
            echo "=== Deployment Status ==="
            sudo kubectl get all -n nimbus
            
            echo "=== Pod Status ==="
            sudo kubectl get pods -n nimbus
            
            echo "=== Service Endpoints ==="
            sudo kubectl get svc -n nimbus
          EOF

  # Job 7: Deployment Summary
  deployment-summary:
    name: Deployment Summary
    needs: [deploy-aws-infrastructure, deploy-azure-infrastructure, run-bootstrap, deploy-to-kubernetes]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Generate Summary
        run: |
          echo "# ðŸŒ¥ Nimbus Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.deploy-aws-infrastructure.result }}" == "success" ]; then
            echo "## âœ… AWS Infrastructure Deployed" >> $GITHUB_STEP_SUMMARY
            echo "- **Instance IP**: ${{ needs.deploy-aws-infrastructure.outputs.instance_ip }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Instance ID**: ${{ needs.deploy-aws-infrastructure.outputs.instance_id }}" >> $GITHUB_STEP_SUMMARY
            echo "- **SSH Command**: \`ssh ubuntu@${{ needs.deploy-aws-infrastructure.outputs.instance_ip }}\`" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-azure-infrastructure.result }}" == "success" ]; then
            echo "## âœ… Azure Infrastructure Deployed" >> $GITHUB_STEP_SUMMARY
            echo "- **VM IP**: ${{ needs.deploy-azure-infrastructure.outputs.instance_ip }}" >> $GITHUB_STEP_SUMMARY
            echo "- **VM ID**: ${{ needs.deploy-azure-infrastructure.outputs.vm_id }}" >> $GITHUB_STEP_SUMMARY
            echo "- **SSH Command**: \`ssh azureuser@${{ needs.deploy-azure-infrastructure.outputs.instance_ip }}\`" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.run-bootstrap.result }}" == "success" ]; then
            echo "## âœ… Bootstrap Completed" >> $GITHUB_STEP_SUMMARY
            echo "All 21 services have been installed:" >> $GITHUB_STEP_SUMMARY
            echo "- k3s, Longhorn, Traefik" >> $GITHUB_STEP_SUMMARY
            echo "- MinIO, OpenFaaS, n8n" >> $GITHUB_STEP_SUMMARY
            echo "- Keycloak, Vault" >> $GITHUB_STEP_SUMMARY
            echo "- NATS, RabbitMQ" >> $GITHUB_STEP_SUMMARY
            echo "- Prometheus, Grafana, Loki" >> $GITHUB_STEP_SUMMARY
            echo "- Velero, Gitea, Drone" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.deploy-to-kubernetes.result }}" == "success" ]; then
            echo "## âœ… Application Deployed" >> $GITHUB_STEP_SUMMARY
            echo "Nimbus UI is now accessible on the cluster" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“š Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. SSH into the instance" >> $GITHUB_STEP_SUMMARY
          echo "2. Check secrets: \`sudo cat /root/.mini-cloud-secrets\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify services: \`kubectl get pods -A\`" >> $GITHUB_STEP_SUMMARY
          echo "4. Access Traefik: \`http://<ip>:30080/dashboard/\`" >> $GITHUB_STEP_SUMMARY
